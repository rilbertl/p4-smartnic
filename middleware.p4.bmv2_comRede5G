/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

#define PKT_INSTANCE_TYPE_NORMAL 0
#define PKT_INSTANCE_TYPE_INGRESS_CLONE 1
#define PKT_INSTANCE_TYPE_EGRESS_CLONE 2
#define PKT_INSTANCE_TYPE_COALESCED 3
#define PKT_INSTANCE_TYPE_INGRESS_RECIRC 4
#define PKT_INSTANCE_TYPE_REPLICATION 5
#define PKT_INSTANCE_TYPE_RESUBMIT 6

const bit<16> TYPE_IPV4 = 0x0800;
const bit<8> PROTO_TCP = 0x06;
const bit<8> PROTO_UDP = 0x11;
const bit<16> TYPE_GTP = 2152;
const bit<8> pdu_container = 133;

typedef bit<16>  egressSpec_t;
typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;
typedef bit<16> port_t;

const ip4Addr_t espelhoIP = 0xC0A83866;
const macAddr_t espelhoMAC = 0x0800271de027; //0x080027e840e6;

const bit<8> CLONE_FL_1 = 1;
const bit<8> CLONE_FL_2 = 2;
const bit<8> CLONE_FL_3 = 3;

/*************************************************************************
*********************** H E A D E R S  ***********************************
*************************************************************************/

header ethernet_t {
	macAddr_t dstAddr;
	macAddr_t srcAddr;
	bit<16>   etherType;
}

header ipv4_t {
	bit<4>    version;
	bit<4>    ihl;
	bit<8>    diffserv;
	bit<16>   totalLen;
	bit<16>   identification;
	bit<3>    flags;
	bit<13>   fragOffset;
	bit<8>    ttl;
	bit<8>    protocol;
	bit<16>   hdrChecksum;
	ip4Addr_t srcAddr;
	ip4Addr_t dstAddr;
}

header tcp_t {
	bit<16> srcPort;
	bit<16> dstPort;
	bit<32> seqNumber;
	bit<32> ackNumber;
	bit<4>  dataOffset;
	bit<3>  res;
	bit<3>  ecn;
	bit<6>  ctrl;
	bit<16> window;
	bit<16> checksum;
	bit<16> urgentPtr;
}

header tcpOptions_t {
	varbit<320> options;
}

header udp_t {
	bit<16> srcPort;
	bit<16> dstPort;
	bit<16> length;
	bit<16> checksum;
}

header gtp_t {
    bit<3>  version_field_id;
    bit<1>  proto_type_id;
    bit<1>  spare;
    bit<1>  extension_header_flag_id;
    bit<1>  sequence_number_flag_id;
    bit<1>  npdu_number_flag_id;
    bit<8>  msgtype;
    bit<16> msglen;
    bit<32> teid;
    bit<24> padding;
}

header gtp_ext_t {
	bit<8> next_extension;
}

header pdu_container_t {
	bit<8> length;
	bit<4> pdu_type;
	bit<5> spare;
	bit<1> rqi;
	bit<6> qosid;
}

struct metadata {

	bool applyChecksum;

	@field_list(CLONE_FL_1)
	ip4Addr_t stored_decapture_ip;
	@field_list(CLONE_FL_1)
	bit<16> stored_source_port;
	@field_list(CLONE_FL_1)
	bit<16> stored_decapture_port;
	@field_list(CLONE_FL_1)
	macAddr_t stored_decapture_mac;
	@field_list(CLONE_FL_1)
	bool removeLen;

	@field_list(CLONE_FL_2)
	ip4Addr_t stored_decapture_ip2;
	@field_list(CLONE_FL_2)
        bit<16> stored_source_port2;
	@field_list(CLONE_FL_2)
        bit<16> stored_decapture_port2;
	@field_list(CLONE_FL_2)
        macAddr_t stored_decapture_mac2;
	@field_list(CLONE_FL_2)
	bool removeLen2;

	@field_list(CLONE_FL_3)
	ip4Addr_t stored_decapture_ip3;
	@field_list(CLONE_FL_3)
        bit<16> stored_source_port3;
	@field_list(CLONE_FL_3)
        bit<16> stored_decapture_port3;
	@field_list(CLONE_FL_3)
        macAddr_t stored_decapture_mac3;
	@field_list(CLONE_FL_3)
	bool removeLen3;

}

struct headers {
	ethernet_t	ethernet;
	ipv4_t		ipv4;
	tcp_t		tcp;
	tcpOptions_t	tcpOptions;
	udp_t		udp;
	gtp_t		gtp;
	gtp_ext_t	gtp_ext;
	pdu_container_t	pdu_container;
	gtp_ext_t	gtp_ext2;
	ipv4_t		ipv4_inner;
	udp_t		udp_inner;
}

/*************************************************************************
*********************** P A R S E R  ***********************************
*************************************************************************/

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

	bit<8> optionsLen;

	state start {
		packet.extract(hdr.ethernet);
		transition select(hdr.ethernet.etherType){
			TYPE_IPV4: parse_ipv4;
			default: accept;
		}
	}

	state parse_ipv4 {
		packet.extract(hdr.ipv4);
		transition select(hdr.ipv4.dstAddr) {
			espelhoIP: parse_transport;
			default: accept;
		}
	}

	state parse_transport {
		transition select(hdr.ipv4.protocol) {
			PROTO_TCP: parse_tcp;
			PROTO_UDP: parse_udp;
			default: accept;
		}
	}

	state parse_gtp {
		packet.extract(hdr.gtp);
		transition select(hdr.gtp.extension_header_flag_id) {
			1: parse_gtp_ext;
			0: parse_ipv4_inner;
		}
	}

	state parse_gtp_ext {
		packet.extract(hdr.gtp_ext);
		transition select(hdr.gtp_ext.next_extension) {
			pdu_container: parse_pdu_container;
			0: parse_ipv4_inner;
		}
	}

	state parse_pdu_container {
		packet.extract(hdr.pdu_container);
		transition parse_gtp_ext2;
	}

	state parse_gtp_ext2 {
		packet.extract(hdr.gtp_ext2);
		transition select(hdr.gtp_ext2.next_extension) {
			0: parse_ipv4_inner;
		}
	}

	state parse_ipv4_inner {
		packet.extract(hdr.ipv4_inner);
		transition select(hdr.ipv4_inner.dstAddr) {
			espelhoIP: parse_transport_inner;
			default: accept;
		}
	}

	state parse_transport_inner {
		transition select(hdr.ipv4_inner.protocol) {
			PROTO_UDP: parse_udp_inner;
			default: accept;
		}
	}
	
	state parse_udp_inner {
    		packet.extract(hdr.udp_inner);
	    	transition accept;
	}

	state parse_tcp {
		packet.extract(hdr.tcp);

        	optionsLen = 4 * (bit<8>) (hdr.tcp.dataOffset - 5);

		transition select (optionsLen) {
			0: accept;
			default: parse_tcp_options;
		}
	}

	state parse_udp {
    		packet.extract(hdr.udp);
	    	transition select(hdr.udp.dstPort) {
			TYPE_GTP: parse_gtp;
			default: accept;
		}
	}

	state parse_tcp_options {
		packet.extract(hdr.tcpOptions, (bit<32>) (optionsLen << 3));
		transition accept;
	}
}


/*************************************************************************
************   C H E C K S U M    V E R I F I C A T I O N   *************
*************************************************************************/

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}


/*************************************************************************
**************  I N G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
	
	action drop() {
		mark_to_drop(standard_metadata);
	}

	action ipv4_forward(egressSpec_t egressPort) {
		standard_metadata.egress_spec = egressPort;
	        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
	}

	
	table ipv4_lpm {
		key = {
		    hdr.ipv4.dstAddr: lpm;
		}
		actions = {
		    ipv4_forward;
		    drop;
		    NoAction;
		}
		size = 1024;
		default_action = NoAction();
    	}

		action encaminhaDecapture_inner (port_t dataPort, ip4Addr_t ip_dec1, port_t port_dec1, macAddr_t mac_dec1, ip4Addr_t ip_dec2, port_t port_dec2, macAddr_t mac_dec2, ip4Addr_t ip_dec3, port_t port_dec3, macAddr_t mac_dec3, ip4Addr_t ip_dec4, port_t port_dec4, macAddr_t mac_dec4) {

                standard_metadata.egress_spec = 2;
                hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
		hdr.udp.srcPort = dataPort;
		hdr.udp.length = hdr.udp.length - 0x2C;
		hdr.ipv4.totalLen = hdr.ipv4.totalLen - 0x2C;

		if (ip_dec1 != 0 && port_dec1 != 0 && mac_dec1 != 0) {
			hdr.ethernet.dstAddr = mac_dec1;
			hdr.ethernet.srcAddr = espelhoMAC;
			hdr.ipv4.srcAddr = espelhoIP;
			hdr.ipv4.dstAddr = ip_dec1;
			//hdr.udp.srcPort = hdr.udp.dstPort;
			hdr.udp.dstPort = port_dec1;
		}
               
		if (ip_dec2 != 0 && port_dec2 != 0 && mac_dec2 != 0) {
			clone_dec2 = 0x1;
			meta.removeLen = false;
			meta.stored_source_port = dataPort;
			meta.stored_decapture_ip = ip_dec2;
			meta.stored_decapture_mac = mac_dec2;
			meta.stored_decapture_port = port_dec2;
		}

		if (ip_dec3 != 0 && port_dec3 != 0 && mac_dec3 != 0) {
			clone_dec3 = 0x1;
			meta.removeLen2 = false;
			meta.stored_source_port2 = dataPort;
			meta.stored_decapture_ip2 = ip_dec3;
			meta.stored_decapture_mac2 = mac_dec3;
			meta.stored_decapture_port2 = port_dec3;
		}

		if (ip_dec4 != 0 && port_dec4 != 0 && mac_dec4 != 0) {
			clone_dec4 = 0x1;
			meta.removeLen3 = false;
			meta.stored_source_port3 = dataPort;
			meta.stored_decapture_ip3 = ip_dec4;
			meta.stored_decapture_mac3 = mac_dec4;
			meta.stored_decapture_port3 = port_dec4;
		}
		
        }



	action encaminhaDecapture (ip4Addr_t ip_dec1, port_t port_dec1, macAddr_t mac_dec1, ip4Addr_t ip_dec2, port_t port_dec2, macAddr_t mac_dec2, ip4Addr_t ip_dec3, port_t port_dec3, macAddr_t mac_dec3, ip4Addr_t ip_dec4, port_t port_dec4, macAddr_t mac_dec4) {

                standard_metadata.egress_spec = 2;
                hdr.ipv4.ttl = hdr.ipv4.ttl - 1;

		if (ip_dec1 != 0 && port_dec1 != 0 && mac_dec1 != 0) {
			hdr.ethernet.dstAddr = mac_dec1;
			hdr.ethernet.srcAddr = espelhoMAC;
			hdr.ipv4.srcAddr = espelhoIP;
			hdr.ipv4.dstAddr = ip_dec1;
			hdr.udp.srcPort = hdr.udp.dstPort;
			hdr.udp.dstPort = port_dec1;
		}
               
		if (ip_dec2 != 0 && port_dec2 != 0 && mac_dec2 != 0) {
			clone_dec2 = 0x1;
			meta.removeLen = true;
			meta.stored_source_port = hdr.udp.srcPort;
			meta.stored_decapture_ip = ip_dec2;
			meta.stored_decapture_mac = mac_dec2;
			meta.stored_decapture_port = port_dec2;
		}

		if (ip_dec3 != 0 && port_dec3 != 0 && mac_dec3 != 0) {
			clone_dec3 = 0x1;
			meta.removeLen2 = true;
			meta.stored_source_port2 = hdr.udp.srcPort;
			meta.stored_decapture_ip2 = ip_dec3;
			meta.stored_decapture_mac2 = mac_dec3;
			meta.stored_decapture_port2 = port_dec3;
		}

		if (ip_dec4 != 0 && port_dec4 != 0 && mac_dec4 != 0) {
			clone_dec4 = 0x1;
			meta.removeLen = true;
			meta.stored_source_port3 = hdr.udp.srcPort;
			meta.stored_decapture_ip3 = ip_dec4;
			meta.stored_decapture_mac3 = mac_dec4;
			meta.stored_decapture_port3 = port_dec4;
		}
		
        }

	table espelho_udp {
		key = { hdr.ipv4.srcAddr : exact;
			hdr.udp.srcPort : exact;
			hdr.ipv4.dstAddr : exact;
			hdr.udp.dstPort : exact; }
		actions = {
			encaminhaDecapture;
			drop;
			NoAction;
		}
		size = 16;
		default_action = NoAction();
	}

	table espelho_udp_inner {
                key = { hdr.udp_inner.srcPort : exact;
                        hdr.ipv4_inner.dstAddr : exact;
                        hdr.udp_inner.dstPort : exact; }
                actions = {
                        encaminhaDecapture_inner;
                        drop;
                        NoAction;
                }
                size = 16;
                default_action = NoAction();
        }

	apply {
		if (hdr.ipv4.isValid()) {
			debug_ipv4.apply();

			meta.applyChecksum = true;

			if (hdr.tcp.isValid()) {
				ipv4_lpm.apply();
			}
			else if (hdr.udp.isValid()) {
				debug_udp.apply();

				if (hdr.gtp.isValid()){
					debug_gtp.apply();
					meta.applyChecksum = false;

					debug_checksum.apply();

					if (hdr.ipv4_inner.isValid()){
						debug_ipv4_inner.apply();

						if (hdr.udp_inner.isValid()){
							debug_udp_inner.apply();
							if (espelho_udp_inner.apply().hit) {

								//Se entrar no Espelho UDP via GTP - Remove cabeÃ§alho GTP - Ativa checksum
								meta.applyChecksum = true;
								hdr.gtp.setInvalid();
								hdr.gtp_ext.setInvalid();
								hdr.pdu_container.setInvalid();
								hdr.gtp_ext2.setInvalid();
								hdr.ipv4_inner.setInvalid();
								hdr.udp_inner.setInvalid();
								
								if (clone_dec2 == 0x1) {
									clone_preserving_field_list(CloneType.I2E, 101, CLONE_FL_1);
								}
								if (clone_dec3 == 0x1) {
									clone_preserving_field_list(CloneType.I2E, 102, CLONE_FL_2);
								}
								if (clone_dec4 == 0x1) {
									clone_preserving_field_list(CloneType.I2E, 103, CLONE_FL_3);
								}
							}
							else {
								ipv4_lpm.apply();
							}
						}
						else {
							ipv4_lpm.apply();
						}
					}
					else {
						ipv4_lpm.apply();
					}
				}
				else {
					if (espelho_udp.apply().hit) {
						if (clone_dec2 == 0x1) {
							clone_preserving_field_list(CloneType.I2E, 101, CLONE_FL_1);
						}
						if (clone_dec3 == 0x1) {
							clone_preserving_field_list(CloneType.I2E, 102, CLONE_FL_2);
						}
						if (clone_dec4 == 0x1) {
							clone_preserving_field_list(CloneType.I2E, 103, CLONE_FL_3);
						}
					}
					else {
						ipv4_lpm.apply();
					}
				}
			}
			else {
				ipv4_lpm.apply();
			}
		}
		else {
			ipv4_lpm.apply();
		}
	}
}

/*************************************************************************
****************  E G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
	
	table debug_checksum {
		key = { meta.applyChecksum : exact; }
		actions = {}
	}

	apply {

		if (standard_metadata.instance_type == PKT_INSTANCE_TYPE_INGRESS_CLONE) {
			//Remove Tunel GTP e Calcula Checksum
			meta.applyChecksum = true;
			hdr.gtp.setInvalid();
			hdr.gtp_ext.setInvalid();
			hdr.pdu_container.setInvalid();
			hdr.gtp_ext2.setInvalid();
			hdr.ipv4_inner.setInvalid();
			hdr.udp_inner.setInvalid();

			if (!meta.removeLen) {
				hdr.udp.length = hdr.udp.length - 0x2C;
				hdr.ipv4.totalLen = hdr.ipv4.totalLen - 0x2C;
			}

			hdr.ipv4.srcAddr = espelhoIP;
			hdr.ipv4.dstAddr = meta.stored_decapture_ip;
			hdr.ethernet.srcAddr = espelhoMAC;
			hdr.ethernet.dstAddr = meta.stored_decapture_mac;
			hdr.udp.srcPort = meta.stored_source_port;
			hdr.udp.dstPort = meta.stored_decapture_port;
			standard_metadata.egress_spec = 2;
		}
		else {
			debug_checksum.apply();
		}
	}
}

/*************************************************************************
*************   C H E C K S U M    C O M P U T A T I O N   **************
*************************************************************************/

control MyComputeChecksum(inout headers hdr, inout metadata meta) {

	apply {
			update_checksum(
				hdr.ipv4.isValid(),
				{ hdr.ipv4.version,
				hdr.ipv4.ihl,
				hdr.ipv4.diffserv,
				hdr.ipv4.totalLen,
				hdr.ipv4.identification,
				hdr.ipv4.flags,
				hdr.ipv4.fragOffset,
				hdr.ipv4.ttl,
				hdr.ipv4.protocol,
				hdr.ipv4.srcAddr,
				hdr.ipv4.dstAddr },
				hdr.ipv4.hdrChecksum,
				HashAlgorithm.csum16
			);
			update_checksum_with_payload(
				meta.applyChecksum,
				{ hdr.ipv4.srcAddr,
				hdr.ipv4.dstAddr,
				8w0,
				hdr.ipv4.protocol,
				hdr.udp.length,
				hdr.udp.srcPort,
				hdr.udp.dstPort,
				hdr.udp.length,
				16w0 
				},
				hdr.udp.checksum,
				HashAlgorithm.csum16
			);
	}
}


/*************************************************************************
***********************  D E P A R S E R  *******************************
*************************************************************************/

control MyDeparser(packet_out packet, in headers hdr) {
	
	apply {
		packet.emit(hdr);
	}
}

/*************************************************************************
***********************  S W I T C H  *******************************
*************************************************************************/

V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;
